{"version":3,"file":"static/js/832.0f9e8ceb.chunk.js","mappings":"sHAmFA,MAEA,EAFoB,IA7EpB,MACEA,WAAAA,GACEC,KAAKC,UAAY,IACnB,CAKA,oBAAMC,GACJ,IACE,MAAMC,QAAiBC,MAAM,GAADC,OAAIC,EAAAA,GAAcC,KAAKC,MAAMC,QAAQ,SAAU,IAAG,eAAe,CAC3FC,OAAQ,MACRC,YAAa,UACbC,QAAS,CACP,eAAgB,sBAIpB,IAAKT,EAASU,GAAI,CAEhBC,QAAQC,KAAK,gCAADV,OAAiCF,EAASa,OAAM,2BAG5D,MAAMC,EAAgBC,KAAKC,SAASC,SAAS,IAAIC,UAAU,EAAG,IAE9D,OADArB,KAAKC,UAAYgB,EACVA,CACT,CAEA,MAAMK,QAAanB,EAASoB,OAE5B,OADAvB,KAAKC,UAAYqB,EAAKrB,UACfD,KAAKC,SACd,CAAE,MAAOuB,GACPV,QAAQC,KAAK,6CAA8CS,GAG3D,MAAMP,EAAgBC,KAAKC,SAASC,SAAS,IAAIC,UAAU,EAAG,IAE9D,OADArB,KAAKC,UAAYgB,EACVA,CACT,CACF,CAKA,kBAAMQ,GAIJ,OAHKzB,KAAKC,iBACFD,KAAKE,iBAENF,KAAKC,SACd,CAKAyB,cAAAA,GACE1B,KAAKC,UAAY,IACnB,CAKA,oBAAM0B,GAAkC,IAAnBC,EAASC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,KAC/B,MACMjB,EAAU,CACd,eAAgB,mBAChB,qBAHsBZ,KAAKyB,gBAU7B,OAJIG,IACFhB,EAAuB,cAAC,UAAAP,OAAauB,IAGhChB,CACT,E","sources":["services/csrfService.js"],"sourcesContent":["/**\n * CSRF Token Service - Handles CSRF token management for secure requests\n */\n\nimport { API_ENDPOINTS } from '../config/api.js';\n\nclass CSRFService {\n  constructor() {\n    this.csrfToken = null;\n  }\n\n  /**\n   * Fetch a CSRF token from the backend\n   */\n  async fetchCSRFToken() {\n    try {\n      const response = await fetch(`${API_ENDPOINTS.auth.login.replace('/login', '')}/csrf-token`, {\n        method: 'GET',\n        credentials: 'include', // Include cookies for session\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        // Instead of throwing, just return a fallback token for now\n        console.warn(`CSRF token endpoint returned ${response.status}, using fallback token`);\n        \n        // Generate a random token as fallback - this might not be secure but helps avoid errors\n        const fallbackToken = Math.random().toString(36).substring(2, 15);\n        this.csrfToken = fallbackToken;\n        return fallbackToken;\n      }\n\n      const data = await response.json();\n      this.csrfToken = data.csrfToken;\n      return this.csrfToken;\n    } catch (error) {\n      console.warn('Error fetching CSRF token, using fallback:', error);\n      \n      // Generate a random token as fallback\n      const fallbackToken = Math.random().toString(36).substring(2, 15);\n      this.csrfToken = fallbackToken;\n      return fallbackToken;\n    }\n  }\n\n  /**\n   * Get the current CSRF token, fetching it if not available\n   */\n  async getCSRFToken() {\n    if (!this.csrfToken) {\n      await this.fetchCSRFToken();\n    }\n    return this.csrfToken;\n  }\n\n  /**\n   * Clear the stored CSRF token (e.g., on logout)\n   */\n  clearCSRFToken() {\n    this.csrfToken = null;\n  }\n\n  /**\n   * Get headers with CSRF token included\n   */\n  async getCSRFHeaders(authToken = null) {\n    const csrfToken = await this.getCSRFToken();\n    const headers = {\n      'Content-Type': 'application/json',\n      'X-CSRF-Token': csrfToken\n    };\n\n    if (authToken) {\n      headers['Authorization'] = `Bearer ${authToken}`;\n    }\n\n    return headers;\n  }\n}\n\n// Create a singleton instance\nconst csrfService = new CSRFService();\n\nexport default csrfService;\n"],"names":["constructor","this","csrfToken","fetchCSRFToken","response","fetch","concat","API_ENDPOINTS","auth","login","replace","method","credentials","headers","ok","console","warn","status","fallbackToken","Math","random","toString","substring","data","json","error","getCSRFToken","clearCSRFToken","getCSRFHeaders","authToken","arguments","length","undefined"],"sourceRoot":""}